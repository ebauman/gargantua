package virtualmachinetemplate

import (
	hfv1 "github.com/hobbyfarm/gargantua/pkg/apis/hobbyfarm.io/v1"
	"github.com/hobbyfarm/gargantua/pkg/apiserver"
	"github.com/hobbyfarm/gargantua/pkg/client/clientset/versioned/typed/hobbyfarm.io/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"strings"
)

type VirtualMachineTemplateServer struct {
	client v1.VirtualMachineTemplateInterface
	dependencies map[string]interface{}
}

const (
	Group = "hobbyfarm.io"
	Version = "v1"
	Kind = "virtualmachinetemplates"
)

// autogenerated
func Register(server *apiserver.APIServer, templateInterface v1.VirtualMachineTemplateInterface, dependencies map[string]interface{}) {
	var gvk = []string{Group, Version, Kind}
	var path = strings.Join(gvk, "/")

	vmts := &VirtualMachineTemplateServer{}
	vmts.client = templateInterface
	vmts.dependencies = dependencies

	server.Get(path, vmts.do_list) // Registers the action with upstream HTTP provider
	server.Get(path + "/:name", vmts.do_get)
	server.Post(path, vmts.do_create)
	server.Put(path + "/:name", vmts.do_update)
	server.Delete(path + "/:name", vmts.do_delete)
}

func (vmts *VirtualMachineTemplateServer) do_list(ctx *apiserver.Context) (interface{}, error) {
	data, err := vmts.ListVirtualMachineTemplate()
	if err !=  nil {
		return nil, err
	}

	return ToOutputList(data), nil
}

func (vmts *VirtualMachineTemplateServer) do_get(ctx *apiserver.Context) (interface{}, error) {
	data, err := vmts.GetVirtualMachineTemplate(ctx.Fiber.Params("name"))
	if err != nil {
		return nil, err
	}

	return ToOutput(data), nil
}

func (vmts *VirtualMachineTemplateServer) do_create(ctx *apiserver.Context) (interface{}, error) {
	obj, err := vmts.pre_CreateVirtualMachineTemplate(ctx)
	if err != nil {
		return nil, err
	}

	data, err := vmts.CreateVirtualMachineTemplate(obj)
	if err != nil {
		return nil, err
	}

	return ToOutput(data), nil
}

func (vmts *VirtualMachineTemplateServer) do_update(ctx *apiserver.Context) (interface{}, error) {
	obj, err := vmts.pre_UpdateVirtualMachineTemplate(ctx)
	if err != nil {
		return nil, err
	}

	data, err := vmts.UpdateVirtualMachineTemplate(obj)
	if err != nil {
		return nil, err
	}

	return ToOutput(data), nil
}

func (vmts *VirtualMachineTemplateServer) do_delete(ctx *apiserver.Context) (interface{}, error) {
	err := vmts.DeleteVirtualMachineTemplate(ctx.Fiber.Params("name"))

	return nil, err
}

func (vmts *VirtualMachineTemplateServer) genericObjectMarshal(ctx *apiserver.Context) (*hfv1.VirtualMachineTemplate, error) {
	// first marshal into a flat vmtemplate
	flatObj := &FlatVirtualMachineTemplate{}

	err := ctx.Fiber.BodyParser(&flatObj)
	if err != nil {
		return nil, err
	}

	err = ctx.Validator.Struct(flatObj)
	if err != nil {
		return nil, err
	}

	// once we have a flat object, then we can convert into a vmtemplate
	obj := FromInput(flatObj)
	return obj, nil
}

func (vmts *VirtualMachineTemplateServer) ListVirtualMachineTemplate() (*[]hfv1.VirtualMachineTemplate, error) {
	data, err := vmts.client.List(metav1.ListOptions{})

	if err != nil {
		return nil, err
	}

	return &data.Items, nil
}

func (vmts *VirtualMachineTemplateServer) GetVirtualMachineTemplate(name string) (*hfv1.VirtualMachineTemplate, error) {
	data, err := vmts.client.Get(name, metav1.GetOptions{})

	if err != nil {
		return nil, err
	}

	return data, nil
}

func (vmts *VirtualMachineTemplateServer) pre_CreateVirtualMachineTemplate(ctx *apiserver.Context) (*hfv1.VirtualMachineTemplate, error) {
	// marshal the incoming object into a VMTemplate
	obj, err := vmts.genericObjectMarshal(ctx)
	if err != nil {
		return nil, err
	}

	return obj, nil
}

func (vmts *VirtualMachineTemplateServer) CreateVirtualMachineTemplate(template *hfv1.VirtualMachineTemplate) (*hfv1.VirtualMachineTemplate, error) {
	data, err := vmts.client.Create(template)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func (vmts *VirtualMachineTemplateServer) pre_UpdateVirtualMachineTemplate(ctx *apiserver.Context) (*hfv1.VirtualMachineTemplate, error) {
	obj, err := vmts.genericObjectMarshal(ctx)

	if err != nil {
		return nil, err
	}

	return obj, nil
}

func (vmts *VirtualMachineTemplateServer) UpdateVirtualMachineTemplate(template *hfv1.VirtualMachineTemplate) (*hfv1.VirtualMachineTemplate, error) {
	data, err := vmts.client.Update(template)

	if err != nil {
		return nil, err
	}

	return data, nil
}

func (vmts *VirtualMachineTemplateServer) DeleteVirtualMachineTemplate(name string) (error)  {
	err := vmts.client.Delete(name, &metav1.DeleteOptions{})

	return err
}